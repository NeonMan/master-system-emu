# data file for the Fltk User Interface Designer (fluid)
version 1.0304
header_name {.h}
code_name {.cxx}
comment {Copyright 2015 Juan Luis Álvarez Martínez

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

} {in_source in_header
}

declblock {\#if 1} {open public after {\#endif}
} {
  decl {\#define __STDC_LIMIT_MACROS} {public global
  }
  decl {\#include <stdint.h>} {public global
  }
  decl {\#include <z80/z80.h>} {public global
  }
  decl {\#include <z80/z80_macros.h>} {public global
  }
  decl {\#include <z80/z80_externs.h>} {public global
  }
  decl {\#include <z80dasm/z80_dasm.h>} {public global
  }
}

class DialogZ80 {
  comment {Shows the z80 internal state} open
} {
  decl {struct z80_s* z80_ptr = 0;} {
    comment {Pointer to z80 internals.} private local
  }
  decl {uint64_t* running_ptr = 0;} {
    comment {A pointer to the z80 clock on/off variable.} private local
  }
  Function {DialogZ80()} {open
  } {
    Fl_Window windowDialog {
      label z80 open
      xywh {364 178 668 299} type Double align 80 visible
    } {
      Fl_Group {} {
        label Registers
        private xywh {0 20 165 265}
      } {
        Fl_Output textAF {
          label AF
          private xywh {25 30 50 30} textfont 13
        }
        Fl_Output textBC {
          label BC
          private xywh {25 60 50 30} textfont 13
        }
        Fl_Output textDE {
          label DE
          private xywh {25 90 50 30} textfont 13
        }
        Fl_Output textHL {
          label HL
          private xywh {25 120 50 30} textfont 13
        }
        Fl_Output textIX {
          label IX
          private xywh {25 150 50 30} textfont 13
        }
        Fl_Output textIY {
          label IY
          private xywh {25 180 50 30} textfont 13
        }
        Fl_Output textSP {
          label SP
          private xywh {25 215 50 30} textfont 13
        }
        Fl_Output textPC {
          label PC
          private xywh {25 245 50 30} textfont 13
        }
        Fl_Output textAFp {
          label {AF'}
          private xywh {110 30 50 30} textfont 13
        }
        Fl_Output textBCp {
          label {BC'}
          private xywh {110 60 50 30} textfont 13
        }
        Fl_Output textDEp {
          label {DE'}
          private xywh {110 90 50 30} textfont 13
        }
        Fl_Output textHLp {
          label {HL'}
          private xywh {110 120 50 30} textfont 13
        }
        Fl_Output textIR {
          label IR
          private xywh {110 150 50 30} textfont 13
        }
      }
      Fl_Group {} {
        label Signals
        private xywh {190 20 235 165}
      } {
        Fl_Check_Button checkM1 {
          label {!M1}
          private xywh {245 25 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkMreq {
          label {!MREQ}
          private xywh {245 45 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkIoreq {
          label {!IOREQ}
          private xywh {245 65 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkRd {
          label {!RD}
          private xywh {245 85 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkWr {
          label {!WR}
          private xywh {245 105 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkRfsh {
          label {!RFSH}
          private xywh {245 125 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkHalt {
          label {!HALT}
          private xywh {245 145 25 25} down_box DOWN_BOX align 4 deactivate
        }
        Fl_Check_Button checkWait {
          label {!WAIT}
          private xywh {330 25 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkInt {
          label {!INT}
          private xywh {330 45 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkNmi {
          label {!NMI}
          private xywh {330 65 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkReset {
          label {!RESET}
          private xywh {330 85 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkClk {
          label {!CLK}
          private xywh {330 105 25 25} down_box DOWN_BOX align 4 deactivate
        }
        Fl_Check_Button checkBusreq {
          label {!BUSRQ}
          private xywh {330 125 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkBusack {
          label {!BUSACK}
          private xywh {330 145 25 25} down_box DOWN_BOX align 4
        }
      }
      Fl_Group {} {
        label Buses
        private xywh {335 195 170 90}
      } {
        Fl_Output textAddress {
          label Address
          private xywh {390 205 105 25} textfont 13
        }
        Fl_Output textData {
          label Data
          private xywh {390 230 105 25} textfont 13
        }
      }
      Fl_Group {} {
        label {Internal state} open
        private xywh {360 25 300 140}
      } {
        Fl_Output textOpcode {
          label Opcode
          private xywh {420 30 240 25} textfont 13
        }
        Fl_Output textStage {
          label Stage
          private xywh {420 80 45 25} textfont 13
        }
        Fl_Output textDasm {
          label Disasm
          private xywh {420 55 240 25} align 7 textfont 13
        }
        Fl_Output textRbuffer {
          label {R Buffer}
          private xywh {420 105 140 25} textfont 13
        }
        Fl_Output textWbuffer {
          label {W Buffer}
          private xywh {420 130 140 25} textfont 13
        }
      }
      Fl_Group {} {
        label Buttons open
        private xywh {360 175 295 100} labeltype NO_LABEL
      } {
        Fl_Light_Button buttonRunning {
          label Running
          callback {uint64_t* volatile rp = running_ptr;
  
  if(this->running_ptr){
    if(o->value())
      *rp = UINT64_MAX;
    else
      *rp = 0;
  }}
          private xywh {530 200 125 25}
        }
        Fl_Button buttonEdge {
          label Edge
          callback {uint64_t* volatile rp = running_ptr;
  
  if(this->running_ptr){
      *rp = (uint64_t) spinEdgecount->value();;
  }} selected
          private xywh {530 225 75 25}
        }
        Fl_Spinner spinEdgecount {
          private xywh {605 225 50 25}
        }
        Fl_Button buttonStep {
          label Step
          private xywh {530 250 125 25} deactivate
        }
      }
      Fl_Group {} {
        label Flags open
        private xywh {175 195 150 105}
      } {
        Fl_Check_Button checkCarry {
          label Carry
          private xywh {225 195 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkAdd {
          label Subtract
          private xywh {225 220 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkParity {
          label Parity
          private xywh {225 245 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkUnk3 {
          label {Unk. (3)}
          private xywh {225 270 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkHCarry {
          label HCarry
          private xywh {300 195 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkUnk5 {
          label {Unk. (5)}
          private xywh {300 220 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkZero {
          label Zero
          private xywh {300 245 25 25} down_box DOWN_BOX align 4
        }
        Fl_Check_Button checkSign {
          label Sign
          private xywh {300 270 25 25} down_box DOWN_BOX align 4
        }
      }
    }
    code {// --- BEGIN Initial vaules ---
//Main registers
this->textAF->value("0x0000 ?");
this->textBC->value("0x0000 ?");
this->textDE->value("0x0000 ?");
this->textHL->value("0x0000 ?");
this->textIX->value("0x0000 ?");
this->textIY->value("0x0000 ?");
this->textSP->value("0x0000 ?");
this->textPC->value("0x0000 ?");
this->textIR->value("0x0000 ?");
//'prime' registers
this->textAFp->value("0x0000 ?");
this->textBCp->value("0x0000 ?");
this->textDEp->value("0x0000 ?");
this->textHLp->value("0x0000 ?");
//Buses
this->textAddress->value("0x0000 ?");
this->textData->value("0x0000 ?");
//Internals
this->textOpcode->value("NOP ?");
this->textStage->value("M1 ?");
//Buttons
this->buttonRunning->value(1);
// --- END Initial values ---} {}
  }
  Function {set_running_ptr(uint64_t* p)} {
    comment {Sets a pointer to the clock on/of var.} open return_type void
  } {
    code {this->running_ptr = p;} {}
  }
  Function {set_z80_ptr(struct z80_s* p)} {
    comment {Sets a pointer to the z80 internals struct.} return_type void
  } {
    code {this->z80_ptr = p;} {}
  }
  Function {update_values()} {
    comment {Updates the dialog values} open return_type void
  } {
    code {if(this->z80_ptr){    
    /*to use the Z80_* macros, the z80
      struct variable must be accesible
      by the identifier 'z80'*/
    \#define z80 (*(this->z80_ptr))
    \#define __TMP_STR_LEN 64
    char tmp_str[__TMP_STR_LEN];
    memset(tmp_str,0,__TMP_STR_LEN);
    
    // --- Flags ---
    checkCarry->value(1  && (Z80_F & Z80_FLAG_CARRY));
    checkAdd->value(1    && (Z80_F & Z80_FLAG_SUBTRACT));
    checkParity->value(1 && (Z80_F & Z80_FLAG_PARITY));
    checkUnk3->value(1   && (Z80_F & Z80_FLAG_UNK3));

    checkHCarry->value(1 && (Z80_F & Z80_FLAG_HC));
    checkUnk5->value(1   && (Z80_F & Z80_FLAG_UNK5));
    checkZero->value(1   && (Z80_F & Z80_FLAG_ZERO));
    checkSign->value(1   && (Z80_F & Z80_FLAG_SIGN));

    // --- Update z80 registers ---
    //AF
    sprintf(tmp_str, "0x%02X%02X", Z80_A, Z80_F);
    textAF->value(tmp_str);
    //BC
    sprintf(tmp_str, "0x%04X", Z80_BC);
    textBC->value(tmp_str);
    //DE
    sprintf(tmp_str, "0x%04X", Z80_DE);
    textDE->value(tmp_str);
    //HL
    sprintf(tmp_str, "0x%04X", Z80_HL);
    textHL->value(tmp_str);
    //IX
    sprintf(tmp_str, "0x%04X", Z80_IX);
    textIX->value(tmp_str);
    //IY
    sprintf(tmp_str, "0x%04X", Z80_IY);
    textIY->value(tmp_str);
    //SP
    sprintf(tmp_str, "0x%04X", Z80_SP);
    textSP->value(tmp_str);
    //PC
    sprintf(tmp_str, "0x%04X", Z80_PC);
    textPC->value(tmp_str);
    
    //AF'
    sprintf(tmp_str, "0x%02X%02X", Z80_Ap, Z80_Fp);
    textAFp->value(tmp_str);
    //BC'
    sprintf(tmp_str, "0x%04X", Z80_BCp);
    textBCp->value(tmp_str);
    //DE'
    sprintf(tmp_str, "0x%04X", Z80_DEp);
    textDEp->value(tmp_str);
    //HL'
    sprintf(tmp_str, "0x%04X", Z80_HLp);
    textHLp->value(tmp_str);
    
    //IR
    sprintf(tmp_str, "0x%02X%02X", Z80_I, Z80_R);
    textIR->value(tmp_str);
    
    // --- Update signals ---
    checkM1->value(1 && z80_n_m1);
    checkMreq->value(1 && z80_n_mreq);
    checkIoreq->value(1 && z80_n_ioreq);
    checkRd->value(1 && z80_n_rd);
    checkWr->value(1 && z80_n_wr);
    checkRfsh->value(1 && z80_n_rfsh);
    //checkHalt->value(1 && z80_n_halt);
    checkWait->value(1 && z80_n_wait);
    checkInt->value(1 && z80_n_int);
    checkNmi->value(1 && z80_n_nmi);
    checkReset->value(1 && z80_n_reset);
    checkBusreq->value(1 && z80_n_busreq);
    checkBusack->value(1 && z80_n_busack);
    
    // --- Update buses ---
    //Data
    sprintf(tmp_str, "0x%04X", z80_data);
    textData->value(tmp_str);
    //Address
    sprintf(tmp_str, "0x%04X", z80_address);
    textAddress->value(tmp_str);
    
    // --- Internals ---
    //Opcode
    sprintf(tmp_str, "%02X %02X %02X %02X (%d)", z80.opcode[0], z80.opcode[1], z80.opcode[2], z80.opcode[3], z80.opcode_index);
    textOpcode->value(tmp_str);
    //Stage
    switch(z80.stage){
      case 0:
      textStage->value("Reset"); break;
      case 1:
      textStage->value("M1"); break;
      case 2:
      textStage->value("M2"); break;
      case 3:
      textStage->value("M3"); break;
      default:
      sprintf(tmp_str, "%d !", z80.stage);
      textStage->value(tmp_str); break;
    }
    //Read buffer
    sprintf(tmp_str, "%02X %02X (%d)", z80.read_buffer[0], z80.read_buffer[1], z80.read_index);
    textRbuffer->value(tmp_str);
    //Write buffer
    sprintf(tmp_str, "%02X %02X (%d)", z80.write_buffer[0], z80.write_buffer[1], z80.write_index);
    textWbuffer->value(tmp_str);
    //Disasm
    z80d_opcode op = z80d_decode_op(z80.opcode, Z80_PC);
    sprintf(tmp_str, "%s ;(Size: %d)", op.opcode_str, op.size);
    textDasm->value(tmp_str);
    \#undef z80
  }} {}
  }
}
